Handlebars.registerHelper("checkboxesListing", function(data, dataAttributes) {
    var firstData = data[0], returnString = "", groups = {}, selectAllStr = Handlebars.helpers.checkboxesSelectAll(dataAttributes);
    if (firstData && firstData.groupLabel) {
        var groups = _.groupBy(data, function(dataItem) {
            return dataItem.groupLabel;
        });
        _.each(groups, function(groupItems, groupLabel) {
            returnString += ADF.templates.inputHelpers.checkboxListingGroupHeader({
                groupLabel: groupLabel,
                selectAllStr: selectAllStr
            }), _.each(groupItems, function(groupItem) {
                returnString += ADF.templates.inputHelpers.checkboxListingItem(groupItem);
            }), returnString += ADF.templates.inputHelpers.checkboxListingGroupFooter();
        });
    } else _.each(data, function(dataItem) {
        returnString += ADF.templates.inputHelpers.checkboxListingItem(dataItem);
    });
    return new Handlebars.SafeString(returnString);
}), Handlebars.registerHelper("checkboxesSelectAll", function(dataAttributes) {
    var selectAllOption = _.findWhere(dataAttributes, {
        name: "select-all-option"
    });
    return selectAllOption && selectAllOption.value ? new Handlebars.SafeString('<button class="adf-checkbox-select-all-toggle">Select All</button>') : void 0;
}), Handlebars.registerHelper("dataAttributeBoolean", function(dataAttributes, attributeName, attributeValue, returnString) {
    return attributeValue ? _.size(_.where(dataAttributes, {
        name: attributeName,
        value: attributeValue
    })) > 0 ? returnString : "" : _.size(_.where(dataAttributes, {
        name: attributeName
    })) > 0 ? returnString : "";
}), Handlebars.registerHelper("dataAttributeWrite", function(dataAttrName, dataAttrValue, locationCode) {
    var configLocation = "wrapper";
    return ADF.config.get("dataAttributes")[dataAttrName] && ADF.config.get("dataAttributes")[dataAttrName].location && (configLocation = ADF.config.get("dataAttributes")[dataAttrName].location), 
    configLocation === locationCode ? new Handlebars.SafeString(" data-" + dataAttrName + '="' + dataAttrValue + '"') : "";
}), Handlebars.registerHelper("json", function(context) {
    return JSON.stringify(context);
}), Handlebars.registerHelper("numberInputMinMaxBuilder", function(stringLength, fillString) {
    for (var retString = "", i = 0; stringLength > i; i++) retString += fillString;
    return retString;
}), Handlebars.registerHelper("optionChecked", function(checkedAttr, value, currentValue) {
    var checkedProperty;
    return checkedProperty = checkedAttr === !0 || "Y" === checkedAttr ? 'checked="checked"' : Array.isArray(currentValue) ? currentValue.indexOf(value) >= 0 ? 'checked="checked"' : "" : _.isUndefined(currentValue) || _.isNull(currentValue) ? "" : value == currentValue ? 'checked="checked"' : "", 
    new Handlebars.SafeString(checkedProperty);
}), Handlebars.registerHelper("optionSelected", function(selectedAttr, value, currentValue) {
    var selectedProperty;
    return selectedProperty = "Y" === selectedAttr ? 'selected="selected"' : Array.isArray(currentValue) ? currentValue.indexOf(value) ? 'selected="selected"' : "" : value == currentValue ? 'selected="selected"' : "", 
    new Handlebars.SafeString(selectedProperty);
}), Handlebars.registerHelper("overlaySummary", function(inputData, dataAttributes) {
    if (!(_.indexOf(inputData, "|") >= 0)) return inputData ? inputData : "Click for details";
    if (!dataAttributes.formatStyle) return inputData.split("|").length + ' records<div class="overlay-details-hover">' + inputData.split("|").join("<br>") + "</div>";
    switch (dataAttributes.formatStyle) {
      case "tilde-delimited-columns":
        return _.each(inputData.split("|"), function(record) {
            return "<tr><td>" + record.split("~").join("</td><td>") + "</td></tr>";
        });

      default:
        return inputData.split("|").join(", ");
    }
}), Handlebars.registerHelper("selectFancyDisplayText", function(currentValue, data) {
    var dataObj = _.findWhere(data, {
        value: currentValue ? currentValue.toString() : ""
    });
    return dataObj ? $.trim($(ADF.templates.inputHelpers.selectFancyRecord(dataObj)).text()) : null;
}), Handlebars.registerHelper("selectFancyLink", function(value, label, tooltip, fieldNames) {
    var returnString = "";
    return fieldNames ? _.each(label.split("|"), function(labelPiece) {
        labelPiece.length > 0 && (returnString += "<td>" + labelPiece + "</td>");
    }) : returnString += value === label ? '<td colspan="2">' + value + "</td>" : "<td>" + value + "</td><td>" + label + "</td>", 
    returnString += ADF.templates.inputHelpers.selectFancyTooltip({
        tooltip: tooltip
    }), new Handlebars.SafeString(returnString);
}), function($) {
    function empty() {}
    jQuery.event.props.push("dataTransfer");
    var default_opts = {
        fallback_id: "",
        url: "",
        refresh: 1e3,
        paramname: "userfile",
        requestType: "POST",
        allowedfileextensions: [],
        allowedfiletypes: [],
        maxfiles: 25,
        maxfilesize: 1,
        queuefiles: 0,
        queuewait: 200,
        data: {},
        headers: {},
        drop: empty,
        dragStart: empty,
        dragEnter: empty,
        dragOver: empty,
        dragLeave: empty,
        docEnter: empty,
        docOver: empty,
        docLeave: empty,
        beforeEach: empty,
        afterAll: empty,
        rename: empty,
        error: function(err, file, i, status) {
            alert(err);
        },
        uploadStarted: empty,
        uploadFinished: empty,
        progressUpdated: empty,
        globalProgressUpdated: empty,
        speedUpdated: empty
    }, errors = [ "BrowserNotSupported", "TooManyFiles", "FileTooLarge", "FileTypeNotAllowed", "NotFound", "NotReadable", "AbortError", "ReadError", "FileExtensionNotAllowed" ];
    $.fn.filedrop = function(options) {
        function drop(e) {
            if (opts.drop.call(this, e) === !1) return !1;
            if (e.dataTransfer) return files = e.dataTransfer.files, null === files || void 0 === files || 0 === files.length ? (opts.error(errors[0]), 
            !1) : (files_count = files.length, upload(), e.preventDefault(), !1);
        }
        function getBuilder(filename, filedata, mime, boundary) {
            var dashdash = "--", crlf = "\r\n", builder = "", paramname = opts.paramname;
            if (opts.data) {
                var params = $.param(opts.data).replace(/\+/g, "%20").split(/&/);
                $.each(params, function() {
                    var pair = this.split("=", 2), name = decodeURIComponent(pair[0]), val = decodeURIComponent(pair[1]);
                    2 === pair.length && (builder += dashdash, builder += boundary, builder += crlf, 
                    builder += 'Content-Disposition: form-data; name="' + name + '"', builder += crlf, 
                    builder += crlf, builder += val, builder += crlf);
                });
            }
            return jQuery.isFunction(paramname) && (paramname = paramname(filename)), builder += dashdash, 
            builder += boundary, builder += crlf, builder += 'Content-Disposition: form-data; name="' + (paramname || "") + '"', 
            builder += '; filename="' + encodeURIComponent(filename) + '"', builder += crlf, 
            builder += "Content-Type: " + mime, builder += crlf, builder += crlf, builder += filedata, 
            builder += crlf, builder += dashdash, builder += boundary, builder += dashdash, 
            builder += crlf;
        }
        function progress(e) {
            if (e.lengthComputable) {
                var percentage = Math.round(100 * e.loaded / e.total);
                if (this.currentProgress !== percentage) {
                    this.currentProgress = percentage, opts.progressUpdated(this.index, this.file, this.currentProgress), 
                    global_progress[this.global_progress_index] = this.currentProgress, globalProgress();
                    var elapsed = new Date().getTime(), diffTime = elapsed - this.currentStart;
                    if (diffTime >= opts.refresh) {
                        var diffData = e.loaded - this.startData, speed = diffData / diffTime;
                        opts.speedUpdated(this.index, this.file, speed), this.startData = e.loaded, this.currentStart = elapsed;
                    }
                }
            }
        }
        function globalProgress() {
            if (0 !== global_progress.length) {
                var index, total = 0;
                for (index in global_progress) global_progress.hasOwnProperty(index) && (total += global_progress[index]);
                opts.globalProgressUpdated(Math.round(total / global_progress.length));
            }
        }
        function upload() {
            if (stop_loop = !1, !files) return opts.error(errors[0]), !1;
            if (opts.allowedfiletypes.push && opts.allowedfiletypes.length) for (var fileIndex = files.length; fileIndex--; ) if (!files[fileIndex].type || $.inArray(files[fileIndex].type, opts.allowedfiletypes) < 0) return opts.error(errors[3], files[fileIndex]), 
            !1;
            if (opts.allowedfileextensions.push && opts.allowedfileextensions.length) for (var fileIndex = files.length; fileIndex--; ) {
                var allowedextension = !1;
                for (i = 0; i < opts.allowedfileextensions.length; i++) files[fileIndex].name.substr(files[fileIndex].name.length - opts.allowedfileextensions[i].length).toLowerCase() == opts.allowedfileextensions[i].toLowerCase() && (allowedextension = !0);
                if (!allowedextension) return opts.error(errors[8], files[fileIndex]), !1;
            }
            var filesDone = 0, filesRejected = 0;
            if (files_count > opts.maxfiles && 0 === opts.queuefiles) return opts.error(errors[1]), 
            !1;
            for (var workQueue = [], processingQueue = [], doneQueue = [], i = 0; files_count > i; i++) workQueue.push(i);
            var pause = function(timeout) {
                setTimeout(process, timeout);
            }, process = function() {
                var fileIndex;
                if (stop_loop) return !1;
                if (opts.queuefiles > 0 && processingQueue.length >= opts.queuefiles) return pause(opts.queuewait);
                fileIndex = workQueue[0], workQueue.splice(0, 1), processingQueue.push(fileIndex);
                try {
                    if (beforeEach(files[fileIndex]) !== !1) {
                        if (fileIndex === files_count) return;
                        var reader = new FileReader(), max_file_size = 1048576 * opts.maxfilesize;
                        if (reader.index = fileIndex, files[fileIndex].size > max_file_size) return opts.error(errors[2], files[fileIndex], fileIndex), 
                        processingQueue.forEach(function(value, key) {
                            value === fileIndex && processingQueue.splice(key, 1);
                        }), filesRejected++, !0;
                        reader.onerror = function(e) {
                            switch (e.target.error.code) {
                              case e.target.error.NOT_FOUND_ERR:
                                return opts.error(errors[4]), !1;

                              case e.target.error.NOT_READABLE_ERR:
                                return opts.error(errors[5]), !1;

                              case e.target.error.ABORT_ERR:
                                return opts.error(errors[6]), !1;

                              default:
                                return opts.error(errors[7]), !1;
                            }
                        }, reader.onloadend = opts.beforeSend ? function(e) {
                            opts.beforeSend(files[fileIndex], fileIndex, function() {
                                send(e);
                            });
                        } : send, reader.readAsDataURL(files[fileIndex]);
                    } else filesRejected++;
                } catch (err) {
                    return processingQueue.forEach(function(value, key) {
                        value === fileIndex && processingQueue.splice(key, 1);
                    }), opts.error(errors[0]), !1;
                }
                workQueue.length > 0 && process();
            }, send = function(e) {
                var fileIndex = (e.srcElement || e.target).index;
                void 0 === e.target.index && (e.target.index = getIndexBySize(e.total));
                var builder, xhr = new XMLHttpRequest(), upload = xhr.upload, file = files[e.target.index], index = e.target.index, start_time = new Date().getTime(), boundary = "------multipartformboundary" + new Date().getTime(), global_progress_index = global_progress.length, newName = rename(file.name), mime = file.type;
                opts.withCredentials && (xhr.withCredentials = opts.withCredentials);
                var data = atob(e.target.result.split(",")[1]);
                builder = "string" == typeof newName ? getBuilder(newName, data, mime, boundary) : getBuilder(file.name, data, mime, boundary), 
                upload.index = index, upload.file = file, upload.downloadStartTime = start_time, 
                upload.currentStart = start_time, upload.currentProgress = 0, upload.global_progress_index = global_progress_index, 
                upload.startData = 0, upload.addEventListener("progress", progress, !1), jQuery.isFunction(opts.url) ? xhr.open(opts.requestType, opts.url(), !0) : xhr.open(opts.requestType, opts.url, !0), 
                xhr.setRequestHeader("content-type", "multipart/form-data; boundary=" + boundary), 
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest"), $.each(opts.headers, function(k, v) {
                    xhr.setRequestHeader(k, v);
                }), xhr.sendAsBinary || (xhr.sendAsBinary = function(datastr) {
                    function byteValue(x) {
                        return 255 & x.charCodeAt(0);
                    }
                    var ords = Array.prototype.map.call(datastr, byteValue), ui8a = new Uint8Array(ords);
                    this.send(ui8a.buffer);
                }), xhr.sendAsBinary(builder), global_progress[global_progress_index] = 0, globalProgress(), 
                opts.uploadStarted(index, file, files_count), xhr.onload = function() {
                    var serverResponse = null;
                    if (xhr.responseText) try {
                        serverResponse = jQuery.parseJSON(xhr.responseText);
                    } catch (e) {
                        serverResponse = xhr.responseText;
                    }
                    var now = new Date().getTime(), timeDiff = now - start_time, result = opts.uploadFinished(index, file, serverResponse, timeDiff, xhr);
                    filesDone++, processingQueue.forEach(function(value, key) {
                        value === fileIndex && processingQueue.splice(key, 1);
                    }), doneQueue.push(fileIndex), global_progress[global_progress_index] = 100, globalProgress(), 
                    filesDone === files_count - filesRejected && afterAll(), result === !1 && (stop_loop = !0), 
                    (xhr.status < 200 || xhr.status > 299) && opts.error(xhr.statusText, file, fileIndex, xhr.status);
                };
            };
            process();
        }
        function getIndexBySize(size) {
            for (var i = 0; files_count > i; i++) if (files[i].size === size) return i;
            return void 0;
        }
        function rename(name) {
            return opts.rename(name);
        }
        function beforeEach(file) {
            return opts.beforeEach(file);
        }
        function afterAll() {
            return opts.afterAll();
        }
        function dragEnter(e) {
            clearTimeout(doc_leave_timer), e.preventDefault(), opts.dragEnter.call(this, e);
        }
        function dragOver(e) {
            clearTimeout(doc_leave_timer), e.preventDefault(), opts.docOver.call(this, e), opts.dragOver.call(this, e);
        }
        function dragLeave(e) {
            clearTimeout(doc_leave_timer), opts.dragLeave.call(this, e), e.stopPropagation();
        }
        function docDrop(e) {
            return e.preventDefault(), opts.docLeave.call(this, e), !1;
        }
        function docEnter(e) {
            return clearTimeout(doc_leave_timer), e.preventDefault(), opts.docEnter.call(this, e), 
            !1;
        }
        function docOver(e) {
            return clearTimeout(doc_leave_timer), e.preventDefault(), opts.docOver.call(this, e), 
            !1;
        }
        function docLeave(e) {
            doc_leave_timer = setTimeout(function(_this) {
                return function() {
                    opts.docLeave.call(_this, e);
                };
            }(this), 200);
        }
        var doc_leave_timer, files, opts = $.extend({}, default_opts, options), global_progress = [], stop_loop = !1, files_count = 0;
        return $("#" + opts.fallback_id).css({
            display: "none",
            width: 0,
            height: 0
        }), this.on("drop", drop).on("dragstart", opts.dragStart).on("dragenter", dragEnter).on("dragover", dragOver).on("dragleave", dragLeave), 
        $(document).on("drop", docDrop).on("dragenter", docEnter).on("dragover", docOver).on("dragleave", docLeave), 
        this.on("click", function(e) {
            $("#" + opts.fallback_id).trigger(e);
        }), $("#" + opts.fallback_id).change(function(e) {
            opts.drop(e), files = e.target.files, files_count = files.length, upload();
        }), this;
    };
    try {
        if (XMLHttpRequest.prototype.sendAsBinary) return;
        XMLHttpRequest.prototype.sendAsBinary = function(datastr) {
            function byteValue(x) {
                return 255 & x.charCodeAt(0);
            }
            var ords = Array.prototype.map.call(datastr, byteValue), ui8a = new Uint8Array(ords);
            "ArrayBufferView" in window ? this.send(ui8a) : this.send(ui8a.buffer);
        };
    } catch (e) {}
}(jQuery), $.fn.formValidate = function(options) {
    var settings = $.extend({
        failClass: "validation-fail",
        passClass: "validation-pass"
    }, options), allValid = !0, checkFunctions = {
        nonempty: function(value, $field, containerData) {
            return value && value.length ? !0 : !1;
        },
        daterange: function(value, $field, containerData) {
            var valueDate = new Date(value), minDate = new Date(), maxDate = new Date();
            if (containerData.validationMinDate) if (containerData.validationMinDate.indexOf("sysdate") >= 0) {
                var stepValue = parseInt(containerData.validationMinDate.split(/[+-]/)[1], 10);
                containerData.validationMinDate.indexOf("-") >= 0 ? minDate.setDate(minDate.getDate() - stepValue) : containerData.validationMinDate.indexOf("+") >= 0 && minDate.setDate(minDate.getDate() + stepValue);
            } else minDate = Date.parse(containerData.validationMinDate); else minDate = valueDate;
            return containerData.validationMaxDate ? containerData.validationMaxDate.indexOf("sysdate") >= 0 ? console.log("uses sysdate") : maxDate = Date.parse(containerData.validationMaxDate) : maxDate = valueDate, 
            valueDate >= minDate && maxDate >= valueDate;
        },
        email: function(value, $field, containerData) {
            var addresses = value.replace(/ /g, "").split(","), passed = 0;
            return 0 === value.length ? !0 : ($.each(addresses, function(addrIdx, addr) {
                passed += settings.emailPattern.test(addr) ? 1 : 0;
            }), passed === addresses.length);
        },
        numeric: function(value, $field, containerData) {
            if (0 === value.length) return !0;
            var patt = /(^[1-9]\d*$)/;
            return value.match(patt) && value.match(patt).length ? !0 : !1;
        },
        url: function(value, $field, containerData) {
            return 0 === value.length ? !0 : ("http" !== value.substr(1, 4) && (value = "http://" + value), 
            settings.urlPattern.test(value));
        },
        lengthRange: function(value, $field, containerData) {
            var minLength = containerData.validationMinLength || value.length, maxLength = containerData.validationMaxLength || value.length;
            return 0 === value.length ? !0 : value.length >= minLength && value.length <= maxLength;
        },
        numberRange: function(value, $field, containerData) {
            var minNumber = containerData.validationMinNumber || value, maxNumber = containerData.validationMaxNumber || value;
            return 0 === value.length ? !0 : value.length >= minNumber && value.length <= maxNumber;
        },
        regex: function(value, $field, containerData) {
            if (0 === value.length) return !0;
            var regex = containerData.validationRegex, patt = new RegExp(regex, "i");
            return null !== value && "" !== value && (value = patt.test(value)), value;
        }
    };
    return this.find(settings.selector).each(function() {
        var $container = $(this), $input = $container.is(":input") ? $container : $container.find(":input"), value = $input.is(":checkbox") || $input.is(":radio") ? $input.is(":checked") ? $input.val() : !1 : $input.val(), containerData = $container.data(), checks = containerData.validationChecks ? containerData.validationChecks.split(",") : [], valid = !0;
        $container.removeClass(settings.failClass + " " + settings.passClass).find(".validation-message").remove(), 
        $.each(checks, function(chkIdx, chkType) {
            checkFunctions[chkType] && !checkFunctions[chkType](value, $input, containerData) ? ($container.addClass(settings.failClass).append('<span class="validation-message">' + containerData["validationMsg" + chkType.charAt(0).toUpperCase() + chkType.slice(1)] + "</span>"), 
            valid = !1, allValid = !1) : $container.addClass(settings.passClass);
        });
    }), allValid;
}, function($) {
    function init(opts) {
        var $menu = $(this), activeRow = null, mouseLocs = [], lastDelayLoc = null, timeoutId = null, options = $.extend({
            rowSelector: "> li",
            submenuSelector: "*",
            submenuDirection: "right",
            tolerance: 75,
            enter: $.noop,
            exit: $.noop,
            activate: $.noop,
            deactivate: $.noop,
            exitMenu: $.noop
        }, opts), MOUSE_LOCS_TRACKED = 3, DELAY = 300, mousemoveDocument = function(e) {
            mouseLocs.push({
                x: e.pageX,
                y: e.pageY
            }), mouseLocs.length > MOUSE_LOCS_TRACKED && mouseLocs.shift();
        }, mouseleaveMenu = function() {
            timeoutId && clearTimeout(timeoutId), options.exitMenu(this) && (activeRow && options.deactivate(activeRow), 
            activeRow = null);
        }, mouseenterRow = function() {
            timeoutId && clearTimeout(timeoutId), options.enter(this), possiblyActivate(this);
        }, mouseleaveRow = function() {
            options.exit(this);
        }, clickRow = function() {
            activate(this);
        }, activate = function(row) {
            row != activeRow && (activeRow && options.deactivate(activeRow), options.activate(row), 
            activeRow = row);
        }, possiblyActivate = function(row) {
            var delay = activationDelay();
            delay ? timeoutId = setTimeout(function() {
                possiblyActivate(row);
            }, delay) : activate(row);
        }, activationDelay = function() {
            function slope(a, b) {
                return (b.y - a.y) / (b.x - a.x);
            }
            if (!activeRow || !$(activeRow).is(options.submenuSelector)) return 0;
            var offset = $menu.offset(), upperLeft = {
                x: offset.left,
                y: offset.top - options.tolerance
            }, upperRight = {
                x: offset.left + $menu.outerWidth(),
                y: upperLeft.y
            }, lowerLeft = {
                x: offset.left,
                y: offset.top + $menu.outerHeight() + options.tolerance
            }, lowerRight = {
                x: offset.left + $menu.outerWidth(),
                y: lowerLeft.y
            }, loc = mouseLocs[mouseLocs.length - 1], prevLoc = mouseLocs[0];
            if (!loc) return 0;
            if (prevLoc || (prevLoc = loc), prevLoc.x < offset.left || prevLoc.x > lowerRight.x || prevLoc.y < offset.top || prevLoc.y > lowerRight.y) return 0;
            if (lastDelayLoc && loc.x == lastDelayLoc.x && loc.y == lastDelayLoc.y) return 0;
            var decreasingCorner = upperRight, increasingCorner = lowerRight;
            "left" == options.submenuDirection ? (decreasingCorner = lowerLeft, increasingCorner = upperLeft) : "below" == options.submenuDirection ? (decreasingCorner = lowerRight, 
            increasingCorner = lowerLeft) : "above" == options.submenuDirection && (decreasingCorner = upperLeft, 
            increasingCorner = upperRight);
            var decreasingSlope = slope(loc, decreasingCorner), increasingSlope = slope(loc, increasingCorner), prevDecreasingSlope = slope(prevLoc, decreasingCorner), prevIncreasingSlope = slope(prevLoc, increasingCorner);
            return prevDecreasingSlope > decreasingSlope && increasingSlope > prevIncreasingSlope ? (lastDelayLoc = loc, 
            DELAY) : (lastDelayLoc = null, 0);
        };
        $menu.mouseleave(mouseleaveMenu).find(options.rowSelector).mouseenter(mouseenterRow).mouseleave(mouseleaveRow).click(clickRow), 
        $(document).mousemove(mousemoveDocument);
    }
    $.fn.menuAim = function(opts) {
        return this.each(function() {
            init.call(this, opts);
        }), this;
    };
}(jQuery), $.fn.serializeObject = function() {
    var o = {}, a = this.serializeArray();
    return $.each(a, function() {
        void 0 !== o[this.name] ? (o[this.name].push || (o[this.name] = [ o[this.name] ]), 
        o[this.name].push(this.value || "")) : o[this.name] = this.value || "";
    }), o;
}, function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery", "jquery.ui" ], factory) : factory(jQuery);
}(function($) {
    if ($.ui.timepicker = $.ui.timepicker || {}, !$.ui.timepicker.version) {
        $.extend($.ui, {
            timepicker: {
                version: "1.5.3"
            }
        });
        var Timepicker = function() {
            this.regional = [], this.regional[""] = {
                currentText: "Now",
                closeText: "Done",
                amNames: [ "AM", "A" ],
                pmNames: [ "PM", "P" ],
                timeFormat: "HH:mm",
                timeSuffix: "",
                timeOnlyTitle: "Choose Time",
                timeText: "Time",
                hourText: "Hour",
                minuteText: "Minute",
                secondText: "Second",
                millisecText: "Millisecond",
                microsecText: "Microsecond",
                timezoneText: "Time Zone",
                isRTL: !1
            }, this._defaults = {
                showButtonPanel: !0,
                timeOnly: !1,
                timeOnlyShowDate: !1,
                showHour: null,
                showMinute: null,
                showSecond: null,
                showMillisec: null,
                showMicrosec: null,
                showTimezone: null,
                showTime: !0,
                stepHour: 1,
                stepMinute: 1,
                stepSecond: 1,
                stepMillisec: 1,
                stepMicrosec: 1,
                hour: 0,
                minute: 0,
                second: 0,
                millisec: 0,
                microsec: 0,
                timezone: null,
                hourMin: 0,
                minuteMin: 0,
                secondMin: 0,
                millisecMin: 0,
                microsecMin: 0,
                hourMax: 23,
                minuteMax: 59,
                secondMax: 59,
                millisecMax: 999,
                microsecMax: 999,
                minDateTime: null,
                maxDateTime: null,
                maxTime: null,
                minTime: null,
                onSelect: null,
                hourGrid: 0,
                minuteGrid: 0,
                secondGrid: 0,
                millisecGrid: 0,
                microsecGrid: 0,
                alwaysSetTime: !0,
                separator: " ",
                altFieldTimeOnly: !0,
                altTimeFormat: null,
                altSeparator: null,
                altTimeSuffix: null,
                altRedirectFocus: !0,
                pickerTimeFormat: null,
                pickerTimeSuffix: null,
                showTimepicker: !0,
                timezoneList: null,
                addSliderAccess: !1,
                sliderAccessArgs: null,
                controlType: "slider",
                oneLine: !1,
                defaultValue: null,
                parse: "strict",
                afterInject: null
            }, $.extend(this._defaults, this.regional[""]);
        };
        $.extend(Timepicker.prototype, {
            $input: null,
            $altInput: null,
            $timeObj: null,
            inst: null,
            hour_slider: null,
            minute_slider: null,
            second_slider: null,
            millisec_slider: null,
            microsec_slider: null,
            timezone_select: null,
            maxTime: null,
            minTime: null,
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            microsec: 0,
            timezone: null,
            hourMinOriginal: null,
            minuteMinOriginal: null,
            secondMinOriginal: null,
            millisecMinOriginal: null,
            microsecMinOriginal: null,
            hourMaxOriginal: null,
            minuteMaxOriginal: null,
            secondMaxOriginal: null,
            millisecMaxOriginal: null,
            microsecMaxOriginal: null,
            ampm: "",
            formattedDate: "",
            formattedTime: "",
            formattedDateTime: "",
            timezoneList: null,
            units: [ "hour", "minute", "second", "millisec", "microsec" ],
            support: {},
            control: null,
            setDefaults: function(settings) {
                return extendRemove(this._defaults, settings || {}), this;
            },
            _newInst: function($input, opts) {
                var tp_inst = new Timepicker(), inlineSettings = {}, fns = {}, overrides, i;
                for (var attrName in this._defaults) if (this._defaults.hasOwnProperty(attrName)) {
                    var attrValue = $input.attr("time:" + attrName);
                    if (attrValue) try {
                        inlineSettings[attrName] = eval(attrValue);
                    } catch (err) {
                        inlineSettings[attrName] = attrValue;
                    }
                }
                overrides = {
                    beforeShow: function(input, dp_inst) {
                        return $.isFunction(tp_inst._defaults.evnts.beforeShow) ? tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst) : void 0;
                    },
                    onChangeMonthYear: function(year, month, dp_inst) {
                        $.isFunction(tp_inst._defaults.evnts.onChangeMonthYear) && tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
                    },
                    onClose: function(dateText, dp_inst) {
                        tp_inst.timeDefined === !0 && "" !== $input.val() && tp_inst._updateDateTime(dp_inst), 
                        $.isFunction(tp_inst._defaults.evnts.onClose) && tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
                    }
                };
                for (i in overrides) overrides.hasOwnProperty(i) && (fns[i] = opts[i] || null);
                tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
                    evnts: fns,
                    timepicker: tp_inst
                }), tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) {
                    return val.toUpperCase();
                }), tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) {
                    return val.toUpperCase();
                }), tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : "") + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : "")), 
                "string" == typeof tp_inst._defaults.controlType ? ("slider" === tp_inst._defaults.controlType && "undefined" == typeof $.ui.slider && (tp_inst._defaults.controlType = "select"), 
                tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType]) : tp_inst.control = tp_inst._defaults.controlType;
                var timezoneList = [ -720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840 ];
                null !== tp_inst._defaults.timezoneList && (timezoneList = tp_inst._defaults.timezoneList);
                var tzl = timezoneList.length, tzi = 0, tzv = null;
                if (tzl > 0 && "object" != typeof timezoneList[0]) for (;tzl > tzi; tzi++) tzv = timezoneList[tzi], 
                timezoneList[tzi] = {
                    value: tzv,
                    label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601)
                };
                return tp_inst._defaults.timezoneList = timezoneList, tp_inst.timezone = null !== tp_inst._defaults.timezone ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : -1 * new Date().getTimezoneOffset(), 
                tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour, 
                tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute, 
                tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second, 
                tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec, 
                tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec, 
                tp_inst.ampm = "", tp_inst.$input = $input, tp_inst._defaults.altField && (tp_inst.$altInput = $(tp_inst._defaults.altField), 
                tp_inst._defaults.altRedirectFocus === !0 && tp_inst.$altInput.css({
                    cursor: "pointer"
                }).focus(function() {
                    $input.trigger("focus");
                })), (0 === tp_inst._defaults.minDate || 0 === tp_inst._defaults.minDateTime) && (tp_inst._defaults.minDate = new Date()), 
                (0 === tp_inst._defaults.maxDate || 0 === tp_inst._defaults.maxDateTime) && (tp_inst._defaults.maxDate = new Date()), 
                void 0 !== tp_inst._defaults.minDate && tp_inst._defaults.minDate instanceof Date && (tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime())), 
                void 0 !== tp_inst._defaults.minDateTime && tp_inst._defaults.minDateTime instanceof Date && (tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime())), 
                void 0 !== tp_inst._defaults.maxDate && tp_inst._defaults.maxDate instanceof Date && (tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime())), 
                void 0 !== tp_inst._defaults.maxDateTime && tp_inst._defaults.maxDateTime instanceof Date && (tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime())), 
                tp_inst.$input.bind("focus", function() {
                    tp_inst._onFocus();
                }), tp_inst;
            },
            _addTimePicker: function(dp_inst) {
                var currDT = $.trim(this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + " " + this.$altInput.val() : this.$input.val());
                this.timeDefined = this._parseTime(currDT), this._limitMinMaxDateTime(dp_inst, !1), 
                this._injectTimePicker(), this._afterInject();
            },
            _parseTime: function(timeString, withDate) {
                if (this.inst || (this.inst = $.datepicker._getInst(this.$input[0])), withDate || !this._defaults.timeOnly) {
                    var dp_dateFormat = $.datepicker._get(this.inst, "dateFormat");
                    try {
                        var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
                        if (!parseRes.timeObj) return !1;
                        $.extend(this, parseRes.timeObj);
                    } catch (err) {
                        return $.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat), 
                        !1;
                    }
                    return !0;
                }
                var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
                return timeObj ? ($.extend(this, timeObj), !0) : !1;
            },
            _afterInject: function() {
                var o = this.inst.settings;
                $.isFunction(o.afterInject) && o.afterInject.call(this);
            },
            _injectTimePicker: function() {
                var $dp = this.inst.dpDiv, o = this.inst.settings, tp_inst = this, litem = "", uitem = "", show = null, max = {}, gridSize = {}, size = null, i = 0, l = 0;
                if (0 === $dp.find("div.ui-timepicker-div").length && o.showTimepicker) {
                    var noDisplay = " ui_tpicker_unit_hide", html = '<div class="ui-timepicker-div' + (o.isRTL ? " ui-timepicker-rtl" : "") + (o.oneLine && "select" === o.controlType ? " ui-timepicker-oneLine" : "") + '"><dl><dt class="ui_tpicker_time_label"' + (o.showTime ? "" : noDisplay) + ">" + o.timeText + '</dt><dd class="ui_tpicker_time ' + (o.showTime ? "" : noDisplay) + '"></dd>';
                    for (i = 0, l = this.units.length; l > i; i++) {
                        if (litem = this.units[i], uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1), 
                        show = null !== o["show" + uitem] ? o["show" + uitem] : this.support[litem], max[litem] = parseInt(o[litem + "Max"] - (o[litem + "Max"] - o[litem + "Min"]) % o["step" + uitem], 10), 
                        gridSize[litem] = 0, html += '<dt class="ui_tpicker_' + litem + "_label" + (show ? "" : noDisplay) + '">' + o[litem + "Text"] + '</dt><dd class="ui_tpicker_' + litem + (show ? "" : noDisplay) + '"><div class="ui_tpicker_' + litem + "_slider" + (show ? "" : noDisplay) + '"></div>', 
                        show && o[litem + "Grid"] > 0) {
                            if (html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>', 
                            "hour" === litem) for (var h = o[litem + "Min"]; h <= max[litem]; h += parseInt(o[litem + "Grid"], 10)) {
                                gridSize[litem]++;
                                var tmph = $.datepicker.formatTime(this.support.ampm ? "hht" : "HH", {
                                    hour: h
                                }, o);
                                html += '<td data-for="' + litem + '">' + tmph + "</td>";
                            } else for (var m = o[litem + "Min"]; m <= max[litem]; m += parseInt(o[litem + "Grid"], 10)) gridSize[litem]++, 
                            html += '<td data-for="' + litem + '">' + (10 > m ? "0" : "") + m + "</td>";
                            html += "</tr></table></div>";
                        }
                        html += "</dd>";
                    }
                    var showTz = null !== o.showTimezone ? o.showTimezone : this.support.timezone;
                    html += '<dt class="ui_tpicker_timezone_label' + (showTz ? "" : noDisplay) + '">' + o.timezoneText + "</dt>", 
                    html += '<dd class="ui_tpicker_timezone' + (showTz ? "" : noDisplay) + '"></dd>', 
                    html += "</dl></div>";
                    var $tp = $(html);
                    for (o.timeOnly === !0 && ($tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all"><div class="ui-datepicker-title">' + o.timeOnlyTitle + "</div></div>"), 
                    $dp.find(".ui-datepicker-header, .ui-datepicker-calendar").hide()), i = 0, l = tp_inst.units.length; l > i; i++) litem = tp_inst.units[i], 
                    uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1), show = null !== o["show" + uitem] ? o["show" + uitem] : this.support[litem], 
                    tp_inst[litem + "_slider"] = tp_inst.control.create(tp_inst, $tp.find(".ui_tpicker_" + litem + "_slider"), litem, tp_inst[litem], o[litem + "Min"], max[litem], o["step" + uitem]), 
                    show && o[litem + "Grid"] > 0 && (size = 100 * gridSize[litem] * o[litem + "Grid"] / (max[litem] - o[litem + "Min"]), 
                    $tp.find(".ui_tpicker_" + litem + " table").css({
                        width: size + "%",
                        marginLeft: o.isRTL ? "0" : size / (-2 * gridSize[litem]) + "%",
                        marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : "0",
                        borderCollapse: "collapse"
                    }).find("td").click(function(e) {
                        var $t = $(this), h = $t.html(), n = parseInt(h.replace(/[^0-9]/g), 10), ap = h.replace(/[^apm]/gi), f = $t.data("for");
                        "hour" === f && (-1 !== ap.indexOf("p") && 12 > n ? n += 12 : -1 !== ap.indexOf("a") && 12 === n && (n = 0)), 
                        tp_inst.control.value(tp_inst, tp_inst[f + "_slider"], litem, n), tp_inst._onTimeChange(), 
                        tp_inst._onSelectHandler();
                    }).css({
                        cursor: "pointer",
                        width: 100 / gridSize[litem] + "%",
                        textAlign: "center",
                        overflow: "hidden"
                    }));
                    if (this.timezone_select = $tp.find(".ui_tpicker_timezone").append("<select></select>").find("select"), 
                    $.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function(val, idx) {
                        return $("<option />").val("object" == typeof val ? val.value : val).text("object" == typeof val ? val.label : val);
                    })), "undefined" != typeof this.timezone && null !== this.timezone && "" !== this.timezone) {
                        var local_timezone = -1 * new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset();
                        local_timezone === this.timezone ? selectLocalTimezone(tp_inst) : this.timezone_select.val(this.timezone);
                    } else "undefined" != typeof this.hour && null !== this.hour && "" !== this.hour ? this.timezone_select.val(o.timezone) : selectLocalTimezone(tp_inst);
                    this.timezone_select.change(function() {
                        tp_inst._onTimeChange(), tp_inst._onSelectHandler(), tp_inst._afterInject();
                    });
                    var $buttonPanel = $dp.find(".ui-datepicker-buttonpane");
                    if ($buttonPanel.length ? $buttonPanel.before($tp) : $dp.append($tp), this.$timeObj = $tp.find(".ui_tpicker_time"), 
                    null !== this.inst) {
                        var timeDefined = this.timeDefined;
                        this._onTimeChange(), this.timeDefined = timeDefined;
                    }
                    if (this._defaults.addSliderAccess) {
                        var sliderAccessArgs = this._defaults.sliderAccessArgs, rtl = this._defaults.isRTL;
                        sliderAccessArgs.isRTL = rtl, setTimeout(function() {
                            if (0 === $tp.find(".ui-slider-access").length) {
                                $tp.find(".ui-slider:visible").sliderAccess(sliderAccessArgs);
                                var sliderAccessWidth = $tp.find(".ui-slider-access:eq(0)").outerWidth(!0);
                                sliderAccessWidth && $tp.find("table:visible").each(function() {
                                    var $g = $(this), oldWidth = $g.outerWidth(), oldMarginLeft = $g.css(rtl ? "marginRight" : "marginLeft").toString().replace("%", ""), newWidth = oldWidth - sliderAccessWidth, newMarginLeft = oldMarginLeft * newWidth / oldWidth + "%", css = {
                                        width: newWidth,
                                        marginRight: 0,
                                        marginLeft: 0
                                    };
                                    css[rtl ? "marginRight" : "marginLeft"] = newMarginLeft, $g.css(css);
                                });
                            }
                        }, 10);
                    }
                    tp_inst._limitMinMaxDateTime(this.inst, !0);
                }
            },
            _limitMinMaxDateTime: function(dp_inst, adjustSliders) {
                var o = this._defaults, dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);
                if (this._defaults.showTimepicker) {
                    if (null !== $.datepicker._get(dp_inst, "minDateTime") && void 0 !== $.datepicker._get(dp_inst, "minDateTime") && dp_date) {
                        var minDateTime = $.datepicker._get(dp_inst, "minDateTime"), minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);
                        (null === this.hourMinOriginal || null === this.minuteMinOriginal || null === this.secondMinOriginal || null === this.millisecMinOriginal || null === this.microsecMinOriginal) && (this.hourMinOriginal = o.hourMin, 
                        this.minuteMinOriginal = o.minuteMin, this.secondMinOriginal = o.secondMin, this.millisecMinOriginal = o.millisecMin, 
                        this.microsecMinOriginal = o.microsecMin), dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime() ? (this._defaults.hourMin = minDateTime.getHours(), 
                        this.hour <= this._defaults.hourMin ? (this.hour = this._defaults.hourMin, this._defaults.minuteMin = minDateTime.getMinutes(), 
                        this.minute <= this._defaults.minuteMin ? (this.minute = this._defaults.minuteMin, 
                        this._defaults.secondMin = minDateTime.getSeconds(), this.second <= this._defaults.secondMin ? (this.second = this._defaults.secondMin, 
                        this._defaults.millisecMin = minDateTime.getMilliseconds(), this.millisec <= this._defaults.millisecMin ? (this.millisec = this._defaults.millisecMin, 
                        this._defaults.microsecMin = minDateTime.getMicroseconds()) : (this.microsec < this._defaults.microsecMin && (this.microsec = this._defaults.microsecMin), 
                        this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.millisecMin = this.millisecMinOriginal, 
                        this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.secondMin = this.secondMinOriginal, 
                        this._defaults.millisecMin = this.millisecMinOriginal, this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.minuteMin = this.minuteMinOriginal, 
                        this._defaults.secondMin = this.secondMinOriginal, this._defaults.millisecMin = this.millisecMinOriginal, 
                        this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.hourMin = this.hourMinOriginal, 
                        this._defaults.minuteMin = this.minuteMinOriginal, this._defaults.secondMin = this.secondMinOriginal, 
                        this._defaults.millisecMin = this.millisecMinOriginal, this._defaults.microsecMin = this.microsecMinOriginal);
                    }
                    if (null !== $.datepicker._get(dp_inst, "maxDateTime") && void 0 !== $.datepicker._get(dp_inst, "maxDateTime") && dp_date) {
                        var maxDateTime = $.datepicker._get(dp_inst, "maxDateTime"), maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);
                        (null === this.hourMaxOriginal || null === this.minuteMaxOriginal || null === this.secondMaxOriginal || null === this.millisecMaxOriginal) && (this.hourMaxOriginal = o.hourMax, 
                        this.minuteMaxOriginal = o.minuteMax, this.secondMaxOriginal = o.secondMax, this.millisecMaxOriginal = o.millisecMax, 
                        this.microsecMaxOriginal = o.microsecMax), dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime() ? (this._defaults.hourMax = maxDateTime.getHours(), 
                        this.hour >= this._defaults.hourMax ? (this.hour = this._defaults.hourMax, this._defaults.minuteMax = maxDateTime.getMinutes(), 
                        this.minute >= this._defaults.minuteMax ? (this.minute = this._defaults.minuteMax, 
                        this._defaults.secondMax = maxDateTime.getSeconds(), this.second >= this._defaults.secondMax ? (this.second = this._defaults.secondMax, 
                        this._defaults.millisecMax = maxDateTime.getMilliseconds(), this.millisec >= this._defaults.millisecMax ? (this.millisec = this._defaults.millisecMax, 
                        this._defaults.microsecMax = maxDateTime.getMicroseconds()) : (this.microsec > this._defaults.microsecMax && (this.microsec = this._defaults.microsecMax), 
                        this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.millisecMax = this.millisecMaxOriginal, 
                        this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.secondMax = this.secondMaxOriginal, 
                        this._defaults.millisecMax = this.millisecMaxOriginal, this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.minuteMax = this.minuteMaxOriginal, 
                        this._defaults.secondMax = this.secondMaxOriginal, this._defaults.millisecMax = this.millisecMaxOriginal, 
                        this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.hourMax = this.hourMaxOriginal, 
                        this._defaults.minuteMax = this.minuteMaxOriginal, this._defaults.secondMax = this.secondMaxOriginal, 
                        this._defaults.millisecMax = this.millisecMaxOriginal, this._defaults.microsecMax = this.microsecMaxOriginal);
                    }
                    if (null !== dp_inst.settings.minTime) {
                        var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
                        this.hour < tempMinTime.getHours() ? (this.hour = this._defaults.hourMin = tempMinTime.getHours(), 
                        this.minute = this._defaults.minuteMin = tempMinTime.getMinutes()) : this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes() ? this.minute = this._defaults.minuteMin = tempMinTime.getMinutes() : this._defaults.hourMin < tempMinTime.getHours() ? (this._defaults.hourMin = tempMinTime.getHours(), 
                        this._defaults.minuteMin = tempMinTime.getMinutes()) : this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes() ? this._defaults.minuteMin = tempMinTime.getMinutes() : this._defaults.minuteMin = 0;
                    }
                    if (null !== dp_inst.settings.maxTime) {
                        var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
                        this.hour > tempMaxTime.getHours() ? (this.hour = this._defaults.hourMax = tempMaxTime.getHours(), 
                        this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes()) : this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes() ? this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes() : this._defaults.hourMax > tempMaxTime.getHours() ? (this._defaults.hourMax = tempMaxTime.getHours(), 
                        this._defaults.minuteMax = tempMaxTime.getMinutes()) : this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes() ? this._defaults.minuteMax = tempMaxTime.getMinutes() : this._defaults.minuteMax = 59;
                    }
                    if (void 0 !== adjustSliders && adjustSliders === !0) {
                        var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10), minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10), secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10), millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10), microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);
                        this.hour_slider && (this.control.options(this, this.hour_slider, "hour", {
                            min: this._defaults.hourMin,
                            max: hourMax,
                            step: this._defaults.stepHour
                        }), this.control.value(this, this.hour_slider, "hour", this.hour - this.hour % this._defaults.stepHour)), 
                        this.minute_slider && (this.control.options(this, this.minute_slider, "minute", {
                            min: this._defaults.minuteMin,
                            max: minMax,
                            step: this._defaults.stepMinute
                        }), this.control.value(this, this.minute_slider, "minute", this.minute - this.minute % this._defaults.stepMinute)), 
                        this.second_slider && (this.control.options(this, this.second_slider, "second", {
                            min: this._defaults.secondMin,
                            max: secMax,
                            step: this._defaults.stepSecond
                        }), this.control.value(this, this.second_slider, "second", this.second - this.second % this._defaults.stepSecond)), 
                        this.millisec_slider && (this.control.options(this, this.millisec_slider, "millisec", {
                            min: this._defaults.millisecMin,
                            max: millisecMax,
                            step: this._defaults.stepMillisec
                        }), this.control.value(this, this.millisec_slider, "millisec", this.millisec - this.millisec % this._defaults.stepMillisec)), 
                        this.microsec_slider && (this.control.options(this, this.microsec_slider, "microsec", {
                            min: this._defaults.microsecMin,
                            max: microsecMax,
                            step: this._defaults.stepMicrosec
                        }), this.control.value(this, this.microsec_slider, "microsec", this.microsec - this.microsec % this._defaults.stepMicrosec));
                    }
                }
            },
            _onTimeChange: function() {
                if (this._defaults.showTimepicker) {
                    var hour = this.hour_slider ? this.control.value(this, this.hour_slider, "hour") : !1, minute = this.minute_slider ? this.control.value(this, this.minute_slider, "minute") : !1, second = this.second_slider ? this.control.value(this, this.second_slider, "second") : !1, millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, "millisec") : !1, microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, "microsec") : !1, timezone = this.timezone_select ? this.timezone_select.val() : !1, o = this._defaults, pickerTimeFormat = o.pickerTimeFormat || o.timeFormat, pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;
                    "object" == typeof hour && (hour = !1), "object" == typeof minute && (minute = !1), 
                    "object" == typeof second && (second = !1), "object" == typeof millisec && (millisec = !1), 
                    "object" == typeof microsec && (microsec = !1), "object" == typeof timezone && (timezone = !1), 
                    hour !== !1 && (hour = parseInt(hour, 10)), minute !== !1 && (minute = parseInt(minute, 10)), 
                    second !== !1 && (second = parseInt(second, 10)), millisec !== !1 && (millisec = parseInt(millisec, 10)), 
                    microsec !== !1 && (microsec = parseInt(microsec, 10)), timezone !== !1 && (timezone = timezone.toString());
                    var ampm = o[12 > hour ? "amNames" : "pmNames"][0], hasChanged = hour !== parseInt(this.hour, 10) || minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && 12 > hour != (-1 !== $.inArray(this.ampm.toUpperCase(), this.amNames)) || null !== this.timezone && timezone !== this.timezone.toString();
                    hasChanged && (hour !== !1 && (this.hour = hour), minute !== !1 && (this.minute = minute), 
                    second !== !1 && (this.second = second), millisec !== !1 && (this.millisec = millisec), 
                    microsec !== !1 && (this.microsec = microsec), timezone !== !1 && (this.timezone = timezone), 
                    this.inst || (this.inst = $.datepicker._getInst(this.$input[0])), this._limitMinMaxDateTime(this.inst, !0)), 
                    this.support.ampm && (this.ampm = ampm), this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o), 
                    this.$timeObj && (pickerTimeFormat === o.timeFormat ? this.$timeObj.text(this.formattedTime + pickerTimeSuffix) : this.$timeObj.text($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix)), 
                    this.timeDefined = !0, hasChanged && this._updateDateTime();
                }
            },
            _onSelectHandler: function() {
                var onSelect = this._defaults.onSelect || this.inst.settings.onSelect, inputEl = this.$input ? this.$input[0] : null;
                onSelect && inputEl && onSelect.apply(inputEl, [ this.formattedDateTime, this ]);
            },
            _updateDateTime: function(dp_inst) {
                dp_inst = this.inst || dp_inst;
                var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay), dt = $.datepicker._daylightSavingAdjust(dtTmp), dateFmt = $.datepicker._get(dp_inst, "dateFormat"), formatCfg = $.datepicker._getFormatConfig(dp_inst), timeAvailable = null !== dt && this.timeDefined;
                this.formattedDate = $.datepicker.formatDate(dateFmt, null === dt ? new Date() : dt, formatCfg);
                var formattedDateTime = this.formattedDate;
                if ("" === dp_inst.lastVal && (dp_inst.currentYear = dp_inst.selectedYear, dp_inst.currentMonth = dp_inst.selectedMonth, 
                dp_inst.currentDay = dp_inst.selectedDay), this._defaults.timeOnly === !0 && this._defaults.timeOnlyShowDate === !1 ? formattedDateTime = this.formattedTime : (this._defaults.timeOnly !== !0 && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === !0 && this._defaults.timeOnlyShowDate === !0) && (formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix), 
                this.formattedDateTime = formattedDateTime, this._defaults.showTimepicker) if (this.$altInput && this._defaults.timeOnly === !1 && this._defaults.altFieldTimeOnly === !0) this.$altInput.val(this.formattedTime), 
                this.$input.val(this.formattedDate); else if (this.$altInput) {
                    this.$input.val(formattedDateTime);
                    var altFormattedDateTime = "", altSeparator = null !== this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator, altTimeSuffix = null !== this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
                    this._defaults.timeOnly || (altFormattedDateTime = this._defaults.altFormat ? $.datepicker.formatDate(this._defaults.altFormat, null === dt ? new Date() : dt, formatCfg) : this.formattedDate, 
                    altFormattedDateTime && (altFormattedDateTime += altSeparator)), altFormattedDateTime += null !== this._defaults.altTimeFormat ? $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix : this.formattedTime + altTimeSuffix, 
                    this.$altInput.val(altFormattedDateTime);
                } else this.$input.val(formattedDateTime); else this.$input.val(this.formattedDate);
                this.$input.trigger("change");
            },
            _onFocus: function() {
                if (!this.$input.val() && this._defaults.defaultValue) {
                    this.$input.val(this._defaults.defaultValue);
                    var inst = $.datepicker._getInst(this.$input.get(0)), tp_inst = $.datepicker._get(inst, "timepicker");
                    if (tp_inst && tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) try {
                        $.datepicker._updateDatepicker(inst);
                    } catch (err) {
                        $.timepicker.log(err);
                    }
                }
            },
            _controls: {
                slider: {
                    create: function(tp_inst, obj, unit, val, min, max, step) {
                        var rtl = tp_inst._defaults.isRTL;
                        return obj.prop("slide", null).slider({
                            orientation: "horizontal",
                            value: rtl ? -1 * val : val,
                            min: rtl ? -1 * max : min,
                            max: rtl ? -1 * min : max,
                            step: step,
                            slide: function(event, ui) {
                                tp_inst.control.value(tp_inst, $(this), unit, rtl ? -1 * ui.value : ui.value), tp_inst._onTimeChange();
                            },
                            stop: function(event, ui) {
                                tp_inst._onSelectHandler();
                            }
                        });
                    },
                    options: function(tp_inst, obj, unit, opts, val) {
                        if (tp_inst._defaults.isRTL) {
                            if ("string" == typeof opts) return "min" === opts || "max" === opts ? void 0 !== val ? obj.slider(opts, -1 * val) : Math.abs(obj.slider(opts)) : obj.slider(opts);
                            var min = opts.min, max = opts.max;
                            return opts.min = opts.max = null, void 0 !== min && (opts.max = -1 * min), void 0 !== max && (opts.min = -1 * max), 
                            obj.slider(opts);
                        }
                        return "string" == typeof opts && void 0 !== val ? obj.slider(opts, val) : obj.slider(opts);
                    },
                    value: function(tp_inst, obj, unit, val) {
                        return tp_inst._defaults.isRTL ? void 0 !== val ? obj.slider("value", -1 * val) : Math.abs(obj.slider("value")) : void 0 !== val ? obj.slider("value", val) : obj.slider("value");
                    }
                },
                select: {
                    create: function(tp_inst, obj, unit, val, min, max, step) {
                        for (var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">', format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat, i = min; max >= i; i += step) sel += '<option value="' + i + '"' + (i === val ? " selected" : "") + ">", 
                        sel += "hour" === unit ? $.datepicker.formatTime($.trim(format.replace(/[^ht ]/gi, "")), {
                            hour: i
                        }, tp_inst._defaults) : "millisec" === unit || "microsec" === unit || i >= 10 ? i : "0" + i.toString(), 
                        sel += "</option>";
                        return sel += "</select>", obj.children("select").remove(), $(sel).appendTo(obj).change(function(e) {
                            tp_inst._onTimeChange(), tp_inst._onSelectHandler(), tp_inst._afterInject();
                        }), obj;
                    },
                    options: function(tp_inst, obj, unit, opts, val) {
                        var o = {}, $t = obj.children("select");
                        if ("string" == typeof opts) {
                            if (void 0 === val) return $t.data(opts);
                            o[opts] = val;
                        } else o = opts;
                        return tp_inst.control.create(tp_inst, obj, $t.data("unit"), $t.val(), o.min >= 0 ? o.min : $t.data("min"), o.max || $t.data("max"), o.step || $t.data("step"));
                    },
                    value: function(tp_inst, obj, unit, val) {
                        var $t = obj.children("select");
                        return void 0 !== val ? $t.val(val) : $t.val();
                    }
                }
            }
        }), $.fn.extend({
            timepicker: function(o) {
                o = o || {};
                var tmp_args = Array.prototype.slice.call(arguments);
                return "object" == typeof o && (tmp_args[0] = $.extend(o, {
                    timeOnly: !0
                })), $(this).each(function() {
                    $.fn.datetimepicker.apply($(this), tmp_args);
                });
            },
            datetimepicker: function(o) {
                o = o || {};
                var tmp_args = arguments;
                return "string" == typeof o ? "getDate" === o || "option" === o && 2 === tmp_args.length && "string" == typeof tmp_args[1] ? $.fn.datepicker.apply($(this[0]), tmp_args) : this.each(function() {
                    var $t = $(this);
                    $t.datepicker.apply($t, tmp_args);
                }) : this.each(function() {
                    var $t = $(this);
                    $t.datepicker($.timepicker._newInst($t, o)._defaults);
                });
            }
        }), $.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
            var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
            if (parseRes.timeObj) {
                var t = parseRes.timeObj;
                parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec), parseRes.date.setMicroseconds(t.microsec);
            }
            return parseRes.date;
        }, $.datepicker.parseTime = function(timeFormat, timeString, options) {
            var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}), strictParse = (-1 !== timeFormat.replace(/\'.*?\'/g, "").indexOf("Z"), 
            function(f, s, o) {
                var treg, getPatternAmpm = function(amNames, pmNames) {
                    var markers = [];
                    return amNames && $.merge(markers, amNames), pmNames && $.merge(markers, pmNames), 
                    markers = $.map(markers, function(val) {
                        return val.replace(/[.*+?|()\[\]{}\\]/g, "\\$&");
                    }), "(" + markers.join("|") + ")?";
                }, getFormatPositions = function(timeFormat) {
                    var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g), orders = {
                        h: -1,
                        m: -1,
                        s: -1,
                        l: -1,
                        c: -1,
                        t: -1,
                        z: -1
                    };
                    if (finds) for (var i = 0; i < finds.length; i++) -1 === orders[finds[i].toString().charAt(0)] && (orders[finds[i].toString().charAt(0)] = i + 1);
                    return orders;
                }, regstr = "^" + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function(match) {
                    var ml = match.length;
                    switch (match.charAt(0).toLowerCase()) {
                      case "h":
                        return 1 === ml ? "(\\d?\\d)" : "(\\d{" + ml + "})";

                      case "m":
                        return 1 === ml ? "(\\d?\\d)" : "(\\d{" + ml + "})";

                      case "s":
                        return 1 === ml ? "(\\d?\\d)" : "(\\d{" + ml + "})";

                      case "l":
                        return "(\\d?\\d?\\d)";

                      case "c":
                        return "(\\d?\\d?\\d)";

                      case "z":
                        return "(z|[-+]\\d\\d:?\\d\\d|\\S+)?";

                      case "t":
                        return getPatternAmpm(o.amNames, o.pmNames);

                      default:
                        return "(" + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function(m) {
                            return "\\" + m;
                        }) + ")?";
                    }
                }).replace(/\s/g, "\\s?") + o.timeSuffix + "$", order = getFormatPositions(f), ampm = "";
                treg = s.match(new RegExp(regstr, "i"));
                var resTime = {
                    hour: 0,
                    minute: 0,
                    second: 0,
                    millisec: 0,
                    microsec: 0
                };
                return treg ? (-1 !== order.t && (void 0 === treg[order.t] || 0 === treg[order.t].length ? (ampm = "", 
                resTime.ampm = "") : (ampm = -1 !== $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function(x, i) {
                    return x.toUpperCase();
                })) ? "AM" : "PM", resTime.ampm = o["AM" === ampm ? "amNames" : "pmNames"][0])), 
                -1 !== order.h && ("AM" === ampm && "12" === treg[order.h] ? resTime.hour = 0 : "PM" === ampm && "12" !== treg[order.h] ? resTime.hour = parseInt(treg[order.h], 10) + 12 : resTime.hour = Number(treg[order.h])), 
                -1 !== order.m && (resTime.minute = Number(treg[order.m])), -1 !== order.s && (resTime.second = Number(treg[order.s])), 
                -1 !== order.l && (resTime.millisec = Number(treg[order.l])), -1 !== order.c && (resTime.microsec = Number(treg[order.c])), 
                -1 !== order.z && void 0 !== treg[order.z] && (resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z])), 
                resTime) : !1;
            }), looseParse = function(f, s, o) {
                try {
                    var d = new Date("2012-01-01 " + s);
                    if (isNaN(d.getTime()) && (d = new Date("2012-01-01T" + s), isNaN(d.getTime()) && (d = new Date("01/01/2012 " + s), 
                    isNaN(d.getTime())))) throw "Unable to parse time with native Date: " + s;
                    return {
                        hour: d.getHours(),
                        minute: d.getMinutes(),
                        second: d.getSeconds(),
                        millisec: d.getMilliseconds(),
                        microsec: d.getMicroseconds(),
                        timezone: -1 * d.getTimezoneOffset()
                    };
                } catch (err) {
                    try {
                        return strictParse(f, s, o);
                    } catch (err2) {
                        $.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
                    }
                }
                return !1;
            };
            return "function" == typeof o.parse ? o.parse(timeFormat, timeString, o) : "loose" === o.parse ? looseParse(timeFormat, timeString, o) : strictParse(timeFormat, timeString, o);
        }, $.datepicker.formatTime = function(format, time, options) {
            options = options || {}, options = $.extend({}, $.timepicker._defaults, options), 
            time = $.extend({
                hour: 0,
                minute: 0,
                second: 0,
                millisec: 0,
                microsec: 0,
                timezone: null
            }, time);
            var tmptime = format, ampmName = options.amNames[0], hour = parseInt(time.hour, 10);
            return hour > 11 && (ampmName = options.pmNames[0]), tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function(match) {
                switch (match) {
                  case "HH":
                    return ("0" + hour).slice(-2);

                  case "H":
                    return hour;

                  case "hh":
                    return ("0" + convert24to12(hour)).slice(-2);

                  case "h":
                    return convert24to12(hour);

                  case "mm":
                    return ("0" + time.minute).slice(-2);

                  case "m":
                    return time.minute;

                  case "ss":
                    return ("0" + time.second).slice(-2);

                  case "s":
                    return time.second;

                  case "l":
                    return ("00" + time.millisec).slice(-3);

                  case "c":
                    return ("00" + time.microsec).slice(-3);

                  case "z":
                    return $.timepicker.timezoneOffsetString(null === time.timezone ? options.timezone : time.timezone, !1);

                  case "Z":
                    return $.timepicker.timezoneOffsetString(null === time.timezone ? options.timezone : time.timezone, !0);

                  case "T":
                    return ampmName.charAt(0).toUpperCase();

                  case "TT":
                    return ampmName.toUpperCase();

                  case "t":
                    return ampmName.charAt(0).toLowerCase();

                  case "tt":
                    return ampmName.toLowerCase();

                  default:
                    return match.replace(/'/g, "");
                }
            });
        }, $.datepicker._base_selectDate = $.datepicker._selectDate, $.datepicker._selectDate = function(id, dateStr) {
            var was_inline, inst = this._getInst($(id)[0]), tp_inst = this._get(inst, "timepicker");
            tp_inst && inst.settings.showTimepicker ? (tp_inst._limitMinMaxDateTime(inst, !0), 
            was_inline = inst.inline, inst.inline = inst.stay_open = !0, this._base_selectDate(id, dateStr), 
            inst.inline = was_inline, inst.stay_open = !1, this._notifyChange(inst), this._updateDatepicker(inst)) : this._base_selectDate(id, dateStr);
        }, $.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker, $.datepicker._updateDatepicker = function(inst) {
            var input = inst.input[0];
            if (!($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input || "boolean" == typeof inst.stay_open && inst.stay_open !== !1)) {
                this._base_updateDatepicker(inst);
                var tp_inst = this._get(inst, "timepicker");
                tp_inst && tp_inst._addTimePicker(inst);
            }
        }, $.datepicker._base_doKeyPress = $.datepicker._doKeyPress, $.datepicker._doKeyPress = function(event) {
            var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker");
            if (tp_inst && $.datepicker._get(inst, "constrainInput")) {
                var ampm = tp_inst.support.ampm, tz = null !== tp_inst._defaults.showTimezone ? tp_inst._defaults.showTimezone : tp_inst.support.timezone, dateChars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat")), datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, "").replace(/TT/g, ampm ? "APM" : "").replace(/Tt/g, ampm ? "AaPpMm" : "").replace(/tT/g, ampm ? "AaPpMm" : "").replace(/T/g, ampm ? "AP" : "").replace(/tt/g, ampm ? "apm" : "").replace(/t/g, ampm ? "ap" : "") + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join("") : "") + tp_inst._defaults.amNames.join("") + tp_inst._defaults.pmNames.join("") + dateChars, chr = String.fromCharCode(void 0 === event.charCode ? event.keyCode : event.charCode);
                return event.ctrlKey || " " > chr || !dateChars || datetimeChars.indexOf(chr) > -1;
            }
            return $.datepicker._base_doKeyPress(event);
        }, $.datepicker._base_updateAlternate = $.datepicker._updateAlternate, $.datepicker._updateAlternate = function(inst) {
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                var altField = tp_inst._defaults.altField;
                if (altField) {
                    var date = (tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat, this._getDate(inst)), formatCfg = $.datepicker._getFormatConfig(inst), altFormattedDateTime = "", altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator, altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix, altTimeFormat = null !== tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;
                    altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix, 
                    tp_inst._defaults.timeOnly || tp_inst._defaults.altFieldTimeOnly || null === date || (altFormattedDateTime = tp_inst._defaults.altFormat ? $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime : tp_inst.formattedDate + altSeparator + altFormattedDateTime), 
                    $(altField).val(inst.input.val() ? altFormattedDateTime : "");
                }
            } else $.datepicker._base_updateAlternate(inst);
        }, $.datepicker._base_doKeyUp = $.datepicker._doKeyUp, $.datepicker._doKeyUp = function(event) {
            var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker");
            if (tp_inst && tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) try {
                $.datepicker._updateDatepicker(inst);
            } catch (err) {
                $.timepicker.log(err);
            }
            return $.datepicker._base_doKeyUp(event);
        }, $.datepicker._base_gotoToday = $.datepicker._gotoToday, $.datepicker._gotoToday = function(id) {
            var inst = this._getInst($(id)[0]), tp_inst = (inst.dpDiv, this._get(inst, "timepicker"));
            selectLocalTimezone(tp_inst);
            var now = new Date();
            this._setTime(inst, now), this._setDate(inst, now), this._base_gotoToday(id);
        }, $.datepicker._disableTimepickerDatepicker = function(target) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                $(target).datepicker("getDate"), tp_inst && (inst.settings.showTimepicker = !1, 
                tp_inst._defaults.showTimepicker = !1, tp_inst._updateDateTime(inst));
            }
        }, $.datepicker._enableTimepickerDatepicker = function(target) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                $(target).datepicker("getDate"), tp_inst && (inst.settings.showTimepicker = !0, 
                tp_inst._defaults.showTimepicker = !0, tp_inst._addTimePicker(inst), tp_inst._updateDateTime(inst));
            }
        }, $.datepicker._setTime = function(inst, date) {
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                var defaults = tp_inst._defaults;
                tp_inst.hour = date ? date.getHours() : defaults.hour, tp_inst.minute = date ? date.getMinutes() : defaults.minute, 
                tp_inst.second = date ? date.getSeconds() : defaults.second, tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec, 
                tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec, tp_inst._limitMinMaxDateTime(inst, !0), 
                tp_inst._onTimeChange(), tp_inst._updateDateTime(inst);
            }
        }, $.datepicker._setTimeDatepicker = function(target, date, withDate) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                if (tp_inst) {
                    this._setDateFromField(inst);
                    var tp_date;
                    date && ("string" == typeof date ? (tp_inst._parseTime(date, withDate), tp_date = new Date(), 
                    tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec), 
                    tp_date.setMicroseconds(tp_inst.microsec)) : (tp_date = new Date(date.getTime()), 
                    tp_date.setMicroseconds(date.getMicroseconds())), "Invalid Date" === tp_date.toString() && (tp_date = void 0), 
                    this._setTime(inst, tp_date));
                }
            }
        }, $.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker, $.datepicker._setDateDatepicker = function(target, _date) {
            var inst = this._getInst(target), date = _date;
            if (inst) {
                "string" == typeof _date && (date = new Date(_date), date.getTime() || (this._base_setDateDatepicker.apply(this, arguments), 
                date = $(target).datepicker("getDate")));
                var tp_date, tp_inst = this._get(inst, "timepicker");
                date instanceof Date ? (tp_date = new Date(date.getTime()), tp_date.setMicroseconds(date.getMicroseconds())) : tp_date = date, 
                tp_inst && tp_date && (tp_inst.support.timezone || null !== tp_inst._defaults.timezone || (tp_inst.timezone = -1 * tp_date.getTimezoneOffset()), 
                date = $.timepicker.timezoneAdjust(date, tp_inst.timezone), tp_date = $.timepicker.timezoneAdjust(tp_date, tp_inst.timezone)), 
                this._updateDatepicker(inst), this._base_setDateDatepicker.apply(this, arguments), 
                this._setTimeDatepicker(target, tp_date, !0);
            }
        }, $.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker, $.datepicker._getDateDatepicker = function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                if (tp_inst) {
                    void 0 === inst.lastVal && this._setDateFromField(inst, noDefault);
                    var date = this._getDate(inst), currDT = $.trim(tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly ? tp_inst.$input.val() + " " + tp_inst.$altInput.val() : tp_inst.$input.val());
                    return date && tp_inst._parseTime(currDT, !inst.settings.timeOnly) && (date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec), 
                    date.setMicroseconds(tp_inst.microsec), null != tp_inst.timezone && (tp_inst.support.timezone || null !== tp_inst._defaults.timezone || (tp_inst.timezone = -1 * date.getTimezoneOffset()), 
                    date = $.timepicker.timezoneAdjust(date, tp_inst.timezone))), date;
                }
                return this._base_getDateDatepicker(target, noDefault);
            }
        }, $.datepicker._base_parseDate = $.datepicker.parseDate, $.datepicker.parseDate = function(format, value, settings) {
            var date;
            try {
                date = this._base_parseDate(format, value, settings);
            } catch (err) {
                if (!(err.indexOf(":") >= 0)) throw err;
                date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(":") - 2)), settings), 
                $.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
            }
            return date;
        }, $.datepicker._base_formatDate = $.datepicker._formatDate, $.datepicker._formatDate = function(inst, day, month, year) {
            var tp_inst = this._get(inst, "timepicker");
            return tp_inst ? (tp_inst._updateDateTime(inst), tp_inst.$input.val()) : this._base_formatDate(inst);
        }, $.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker, $.datepicker._optionDatepicker = function(target, name, value) {
            var name_clone, inst = this._getInst(target);
            if (!inst) return null;
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                var prop, ret, oldVal, $target, min = null, max = null, onselect = null, overrides = tp_inst._defaults.evnts, fns = {};
                if ("string" == typeof name) {
                    if ("minDate" === name || "minDateTime" === name) min = value; else if ("maxDate" === name || "maxDateTime" === name) max = value; else if ("onSelect" === name) onselect = value; else if (overrides.hasOwnProperty(name)) {
                        if ("undefined" == typeof value) return overrides[name];
                        fns[name] = value, name_clone = {};
                    }
                } else if ("object" == typeof name) {
                    name.minDate ? min = name.minDate : name.minDateTime ? min = name.minDateTime : name.maxDate ? max = name.maxDate : name.maxDateTime && (max = name.maxDateTime);
                    for (prop in overrides) overrides.hasOwnProperty(prop) && name[prop] && (fns[prop] = name[prop]);
                }
                for (prop in fns) fns.hasOwnProperty(prop) && (overrides[prop] = fns[prop], name_clone || (name_clone = $.extend({}, name)), 
                delete name_clone[prop]);
                if (name_clone && isEmptyObject(name_clone)) return;
                if (min ? (min = 0 === min ? new Date() : new Date(min), tp_inst._defaults.minDate = min, 
                tp_inst._defaults.minDateTime = min) : max ? (max = 0 === max ? new Date() : new Date(max), 
                tp_inst._defaults.maxDate = max, tp_inst._defaults.maxDateTime = max) : onselect && (tp_inst._defaults.onSelect = onselect), 
                min || max) return $target = $(target), oldVal = $target.datetimepicker("getDate"), 
                ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value), 
                $target.datetimepicker("setDate", oldVal), ret;
            }
            return void 0 === value ? this._base_optionDatepicker.call($.datepicker, target, name) : this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
        };
        var isEmptyObject = function(obj) {
            var prop;
            for (prop in obj) if (obj.hasOwnProperty(prop)) return !1;
            return !0;
        }, extendRemove = function(target, props) {
            $.extend(target, props);
            for (var name in props) (null === props[name] || void 0 === props[name]) && (target[name] = props[name]);
            return target;
        }, detectSupport = function(timeFormat) {
            var tf = timeFormat.replace(/'.*?'/g, "").toLowerCase(), isIn = function(f, t) {
                return -1 !== f.indexOf(t) ? !0 : !1;
            };
            return {
                hour: isIn(tf, "h"),
                minute: isIn(tf, "m"),
                second: isIn(tf, "s"),
                millisec: isIn(tf, "l"),
                microsec: isIn(tf, "c"),
                timezone: isIn(tf, "z"),
                ampm: isIn(tf, "t") && isIn(timeFormat, "h"),
                iso8601: isIn(timeFormat, "Z")
            };
        }, convert24to12 = function(hour) {
            return hour %= 12, 0 === hour && (hour = 12), String(hour);
        }, computeEffectiveSetting = function(settings, property) {
            return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
        }, splitDateTime = function(dateTimeString, timeSettings) {
            var separator = computeEffectiveSetting(timeSettings, "separator"), format = computeEffectiveSetting(timeSettings, "timeFormat"), timeParts = format.split(separator), timePartsLen = timeParts.length, allParts = dateTimeString.split(separator), allPartsLen = allParts.length;
            return allPartsLen > 1 ? {
                dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
                timeString: allParts.splice(0, timePartsLen).join(separator)
            } : {
                dateString: dateTimeString,
                timeString: ""
            };
        }, parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
            var date, parts, parsedTime;
            if (parts = splitDateTime(dateTimeString, timeSettings), date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings), 
            "" === parts.timeString) return {
                date: date
            };
            if (parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings), 
            !parsedTime) throw "Wrong time format";
            return {
                date: date,
                timeObj: parsedTime
            };
        }, selectLocalTimezone = function(tp_inst, date) {
            if (tp_inst && tp_inst.timezone_select) {
                var now = date || new Date();
                tp_inst.timezone_select.val(-now.getTimezoneOffset());
            }
        };
        $.timepicker = new Timepicker(), $.timepicker.timezoneOffsetString = function(tzMinutes, iso8601) {
            if (isNaN(tzMinutes) || tzMinutes > 840 || -720 > tzMinutes) return tzMinutes;
            var off = tzMinutes, minutes = off % 60, hours = (off - minutes) / 60, iso = iso8601 ? ":" : "", tz = (off >= 0 ? "+" : "-") + ("0" + Math.abs(hours)).slice(-2) + iso + ("0" + Math.abs(minutes)).slice(-2);
            return "+00:00" === tz ? "Z" : tz;
        }, $.timepicker.timezoneOffsetNumber = function(tzString) {
            var normalized = tzString.toString().replace(":", "");
            return "Z" === normalized.toUpperCase() ? 0 : /^(\-|\+)\d{4}$/.test(normalized) ? ("-" === normalized.substr(0, 1) ? -1 : 1) * (60 * parseInt(normalized.substr(1, 2), 10) + parseInt(normalized.substr(3, 2), 10)) : tzString;
        }, $.timepicker.timezoneAdjust = function(date, toTimezone) {
            var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
            return isNaN(toTz) || date.setMinutes(date.getMinutes() + -date.getTimezoneOffset() - toTz), 
            date;
        }, $.timepicker.timeRange = function(startTime, endTime, options) {
            return $.timepicker.handleRange("timepicker", startTime, endTime, options);
        }, $.timepicker.datetimeRange = function(startTime, endTime, options) {
            $.timepicker.handleRange("datetimepicker", startTime, endTime, options);
        }, $.timepicker.dateRange = function(startTime, endTime, options) {
            $.timepicker.handleRange("datepicker", startTime, endTime, options);
        }, $.timepicker.handleRange = function(method, startTime, endTime, options) {
            function checkDates(changed, other) {
                var startdt = startTime[method]("getDate"), enddt = endTime[method]("getDate"), changeddt = changed[method]("getDate");
                if (null !== startdt) {
                    var minDate = new Date(startdt.getTime()), maxDate = new Date(startdt.getTime());
                    minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval), maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval), 
                    options.minInterval > 0 && minDate > enddt ? endTime[method]("setDate", minDate) : options.maxInterval > 0 && enddt > maxDate ? endTime[method]("setDate", maxDate) : startdt > enddt && other[method]("setDate", changeddt);
                }
            }
            function selected(changed, other, option) {
                if (changed.val()) {
                    var date = changed[method].call(changed, "getDate");
                    null !== date && options.minInterval > 0 && ("minDate" === option && date.setMilliseconds(date.getMilliseconds() + options.minInterval), 
                    "maxDate" === option && date.setMilliseconds(date.getMilliseconds() - options.minInterval)), 
                    date.getTime && other[method].call(other, "option", option, date);
                }
            }
            options = $.extend({}, {
                minInterval: 0,
                maxInterval: 0,
                start: {},
                end: {}
            }, options);
            var timeOnly = !1;
            return "timepicker" === method && (timeOnly = !0, method = "datetimepicker"), $.fn[method].call(startTime, $.extend({
                timeOnly: timeOnly,
                onClose: function(dateText, inst) {
                    checkDates($(this), endTime);
                },
                onSelect: function(selectedDateTime) {
                    selected($(this), endTime, "minDate");
                }
            }, options, options.start)), $.fn[method].call(endTime, $.extend({
                timeOnly: timeOnly,
                onClose: function(dateText, inst) {
                    checkDates($(this), startTime);
                },
                onSelect: function(selectedDateTime) {
                    selected($(this), startTime, "maxDate");
                }
            }, options, options.end)), checkDates(startTime, endTime), selected(startTime, endTime, "minDate"), 
            selected(endTime, startTime, "maxDate"), $([ startTime.get(0), endTime.get(0) ]);
        }, $.timepicker.log = function() {
            window.console && window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
        }, $.timepicker._util = {
            _extendRemove: extendRemove,
            _isEmptyObject: isEmptyObject,
            _convert24to12: convert24to12,
            _detectSupport: detectSupport,
            _selectLocalTimezone: selectLocalTimezone,
            _computeEffectiveSetting: computeEffectiveSetting,
            _splitDateTime: splitDateTime,
            _parseDateTimeInternal: parseDateTimeInternal
        }, Date.prototype.getMicroseconds || (Date.prototype.microseconds = 0, Date.prototype.getMicroseconds = function() {
            return this.microseconds;
        }, Date.prototype.setMicroseconds = function(m) {
            return this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1e3)), this.microseconds = m % 1e3, 
            this;
        }), $.timepicker.version = "1.5.3";
    }
});
//# sourceMappingURL=plugins.min.js.map